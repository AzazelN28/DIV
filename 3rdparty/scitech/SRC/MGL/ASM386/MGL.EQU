;****************************************************************************
;*
;*						MegaGraph Graphics Library
;*
;*               Copyright (C) 1991-1997 SciTech Software, Inc.
;*                            All rights reserved.
;*
;*  ======================================================================
;*       This library is free software; you can use it and/or
;*       modify it under the terms of the SciTech MGL Software License.
;*
;*       This library is distributed in the hope that it will be useful,
;*       but WITHOUT ANY WARRANTY; without even the implied warranty of
;*       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;*       SciTech MGL Software License for more details.
;*  ======================================================================
;*
;* Filename:    $Workfile:   mgl.equ  $
;* Version:     $Revision:   1.29  $
;*
;* Language:	80386 Assembler
;* Environment:	IBM PC (MS DOS)
;*
;* Description:	All the equates and = directives used by the MegaGraph
;*				graphic library assembly modules are contained within this
;*				file for use by the various assembly modules.
;*
;*				Note that we define the assembly language equivalent to
;*				the MGL structures, and set up macros to access the
;*				structures through ES:BX (or simple EBX in the FLAT model)
;*              to simplify normal coding.
;*
;* $Date:   05 Nov 1997 18:32:00  $ $Author:   KendallB  $
;*
;****************************************************************************

ifdef   MGL_LITE
else
ifdef	MGL_PRO
else
ifdef	MGL_FLT3D
MGL_3D				= 1
else
MGL_FIX3D			= 1		; Default is MGL_FIX3D
MGL_3D				= 1
endif
endif
endif

typedef color_t     ulong
typedef fix32_t 	ulong
typedef	zfix32_t	ulong
typedef	fxcolor_t	ulong

true				=	1
false				=	0
MGL_VIRTUAL_ACCESS	=   01h
MGL_FIX_1			=	10000h
MGL_FIX_HALF		=	08000h

enum color_mode {
	MGL_CMAP_MODE
	MGL_DITHER_RGB_MODE
	}

enum write_mode {
	MGL_REPLACE_MODE
	MGL_AND_MODE
	MGL_OR_MODE
	MGL_XOR_MODE
	}

enum fill_style {
	MGL_BITMAP_SOLID
	MGL_BITMAP_OPAQUE
	MGL_BITMAP_TRANSPARENT
	MGL_PIXMAP
	}

enum polygon_types {
	MGL_CONVEX_POLYGON
	MGL_COMPLEX_POLYGON
	MGL_AUTO_POLYGON
	}

enum text_just {
	MGL_LEFT_TEXT
	MGL_TOP_TEXT
	MGL_CENTER_TEXT
	MGL_RIGHT_TEXT
	MGL_BOTTOM_TEXT=2
	MGL_BASELINE_TEXT
	}

enum text_dir {
	MGL_LEFT_DIR
	MGL_UP_DIR
	MGL_RIGHT_DIR
	MGL_DOWN_DIR
	}

enum pal_rotatate_type {
	MGL_ROTATE_UP
	MGL_ROTATE_DOWN
	}

; Structure definitions

struc 	point_s
x     					uint	?
y     					uint  	?
ends  	point_s
point	= (point_s PTR _ES _BX)

struc	rect_s
left					uint	?
top     				uint	?
right					uint	?
bottom					uint	?
ends	rect_s
rect	= (rect_s PTR _ES _BX)

struc	rectFX_s
left					fix32_t	?
top     				fix32_t	?
right					fix32_t	?
bottom					fix32_t	?
ends	rectFX_s
rectFX	= (rectFX_s PTR _ES _BX)

struc 	fxpoint
x						fix32_t	?
y						fix32_t	?
ends  	fxpoint

struc 	fxrgb
r						fix32_t	?
g						fix32_t	?
b						fix32_t	?
ends  	fxrgb

struc 	fxtex
w						fix32_t	?
s						fix32_t	?
t						fix32_t	?
ends  	fxtex

struc 	fxpointc
c						fix32_t	?
p						fxpoint <>
ends  	fxpointc

struc 	fxpointrgb
c						fxrgb	<>
p						fxpoint <>
ends  	fxpointrgb

struc 	fxpointz
p						fxpoint <>
z						zfix32_t ?
ends  	fxpointz

struc 	fxpointcz
c						fix32_t	?
p						fxpoint <>
z						zfix32_t ?
ends  	fxpointcz

struc 	fxpointrgbz
c						fxrgb	<>
p						fxpoint <>
z						zfix32_t ?
ends  	fxpointrgbz

struc 	segment_s
next					dptr	?
x						ushort	?
ends	segment_s
segmnt = (segment_s PTR _ES _BX)

struc	span_s
next					dptr	?
seg						dptr	?
y						ushort	?
ends	span_s
span = (span_s PTR _ES _BX)

struc	region_s
bounds					rect_s	?
spans					dptr	?
ends	region_s
region = (span_s PTR _ES _BX)

struc	MGL_cursor_s
xorMask					ulong 32 dup (?)
andMask					ulong 32 dup (?)
xHotSpot				uint	?
yHotSpot				uint	?
ends	MGL_cursor_s
MGL_cursor = (MGL_cursor_s PTR _ES _BX)

struc   pixel_format_s
redMask             	uint   	?
greenMask           	uint   	?
blueMask            	uint   	?
rsvdMask            	uint   	?
redPos              	uint    ?
redAdjust           	uint    ?
greenPos            	uint    ?
greenAdjust         	uint    ?
bluePos             	uint    ?
blueAdjust          	uint    ?
rsvdPos             	uint    ?
rsvdAdjust          	uint	?
ends	pixel_format_s
pixel_format	= (pixel_format_s PTR _ES _BX)

struc	text_settings_s
horizJust           	uint    ?
vertJust            	uint    ?
dir                 	uint    ?
szNumerx            	uint    ?
szNumery            	uint    ?
szDenomx            	uint    ?
szDenomy            	uint    ?
spaceExtra          	uint    ?
font                	dptr	?
ends    text_settings_s
text_settings 	= (text_settings_s PTR _ES _BX)

struc	attributes_s
color               	color_t ?
backColor           	color_t	?
colorMode				uint	?
markerSize          	uint  	?
markerStyle         	uint	?
markerColor         	color_t ?
bdrBright           	color_t ?
bdrDark             	color_t ?
CP                  	point_s	<>
writeMode				uint	?
penStyle				uint	?
penHeight           	uint    ?
penWidth            	uint    ?
penPat              	db 8 DUP (?)
penPixPat           	color_t 64 DUP (?)
lineStyle				uint	?
lineStipple				uint	?
stippleCount			uint	?
viewPort            	rect_s 	<>
viewPortOrg				point_s <>
clipRect            	rect_s 	<>
clip                	bool	?
polyType            	uint	?
ts                  	text_settings_s <>
ends	attributes_s
attributes		= (attributes_s PTR _ES _BX)

struc	MGLVisual_s
rgb_flag				bool	?
alpha_flag				bool	?
db_flag					bool	?
depth_size				uint	?
stencil_size			uint	?
accum_size				uint	?
ends	MGLVisual_s

struc	arc_coords_s
x						uint	?
y						uint	?
startX					uint	?
startY					uint	?
endX					uint	?
endY					uint	?
ends	arc_coords_s
arc_coords		= (arc_coords_s PTR _ES _BX)

struc   display_vec_s
destroy					cptr	?
refCount				uint	?
hwnd					ulong	?

graphDriver				uint	?
graphMode				uint	?
maxProgram				uint	?
widePalette				uint	?
activePage				uint	?
visualPage				uint	?
hardwareCursor			uint	?
isStereo				uint	?
stereoRunning			uint	?
refreshRate				uint	?
inited					bool	?

restoreTextMode         cptr    ?
restoreGraphMode		cptr	?
setActivePage       	cptr    ?
setVisualPage       	cptr    ?
vSync               	cptr    ?
setCursor           	cptr    ?
setCursorPos        	cptr    ?
showCursor          	cptr    ?
setCursorColor			cptr	?
makeOffscreenDC			cptr	?
makeLinearOffscreenDC	cptr	?
setDisplayStart			cptr	?
startStereo				cptr	?
stopStereo				cptr	?
ends	display_vec_s
dispVec				= (display_vec_s PTR _ES _BX)

struc	mode_t_s
xRes					uint	?
yRes					uint	?
bitsPerPixel			uint	?
numberOfPlanes			uint	?
maxColor            	color_t ?
maxPage             	uint    ?
bytesPerLine        	uint    ?
aspectRatio         	uint    ?
pageSize            	ulong   ?
scratch1            	uint    ?
scratch2            	uint    ?
redMaskSize         	uint   	?
redFieldPosition    	uint   	?
greenMaskSize       	uint   	?
greenFieldPosition  	uint   	?
blueMaskSize        	uint   	?
blueFieldPosition   	uint   	?
rsvdMaskSize        	uint   	?
rsvdFieldPosition   	uint   	?
modeFlags				ulong	?
ends	mode_t_s
mode_t			= (mode_t_s PTR _ES _BX)

; Internal structure for trapezoid rendering

struc	trap_t_s
y						uint	?
count					uint	?
x1						fix32_t	?
x2						fix32_t	?
slope1					fix32_t	?
slope2					fix32_t	?
z0						zfix32_t ?
dZdX					zfix32_t ?
dZdY					zfix32_t ?
c1						fix32_t	?
c2						fix32_t	?
cSlope1					fix32_t	?
cSlope2					fix32_t	?
r1						fix32_t	?
r2						fix32_t	?
g1						fix32_t	?
g2						fix32_t	?
b1						fix32_t	?
b2						fix32_t	?
rSlope1					fix32_t	?
rSlope2					fix32_t	?
gSlope1					fix32_t	?
gSlope2					fix32_t	?
bSlope1					fix32_t	?
bSlope2					fix32_t	?
ends	trap_t_s

ifdef	__WINDOWS__

ifdef	__WINDOWS16__
typedef handle			ushort
endif
ifdef	__WIN386__
typedef handle			ushort
endif
ifdef	__WINDOWS32__
typedef handle			ulong
endif

; Internal Windows device specific structures

struc	gendc_vars_s
hdc						handle		?
glrc					handle		?
cosmoCtx				dptr		?
cosmoSurf				dptr		?
ends	gendc_vars_s

struc	fulldc_vars_s
hdc						handle		?
glrc					handle		?
cosmoCtx				dptr		?
cosmoSurf				dptr		?
ends	fulldc_vars_s

struc	memdc_vars_s
hdc						handle		?
glrc					handle		?
cosmoCtx				dptr		?
cosmoSurf				dptr		?
hbm						handle		?
ends	memdc_vars_s

struc	windc_vars_s
hdc						handle		?
glrc					handle		?
cosmoCtx				dptr		?
cosmoSurf				dptr		?
hwnd					handle		?
hpal					handle		?
palNoStatic				bool		?
isBackground			bool		?
ends	windc_vars_s

union	wm_vars_s
gendc					gendc_vars_s <>
fulldc					fulldc_vars_s <>
windc					windc_vars_s <>
memdc					memdc_vars_s <>
ends	wm_vars_s

else

; Dummy DOS specific structures

union	wm_vars_s
unused					ulong		?
ends	wm_vars_s

endif

struc	rVecs_s
line					cptr		?
scanLine                cptr		?
fillRect                cptr		?
drawScanList            cptr		?
trap                    cptr		?
drawRegion              cptr		?
ellipse                 cptr		?
fillEllipse             cptr		?
ellipseArc              cptr		?
fillEllipseArc          cptr		?
ends	rVecs_s

struc	zVecs_s
zClear					cptr		?
zLine					cptr		?
zDitherLine				cptr		?
czLine					cptr		?
rgbzLine				cptr		?
zTri					cptr		?
zDitherTri				cptr		?
czTri					cptr		?
rgbzTri					cptr		?
zQuad					cptr		?
zDitherQuad				cptr		?
czQuad					cptr		?
rgbzQuad				cptr		?
zTrap					cptr		?
zDitherTrap				cptr		?
czTrap					cptr		?
rgbzTrap				cptr		?
ends	zVecs_s

struc	vecs_s
getWinDC				cptr		?
getDefaultPalette   	cptr        ?
realizePalette      	cptr        ?
setColor            	cptr        ?
setBackColor        	cptr        ?
setClipRect         	cptr        ?
beginDirectAccess       cptr        ?
endDirectAccess         cptr        ?
beginPixel          	cptr        ?
getPixel            	cptr        ?
putPixel            	cptr        ?
endPixel            	cptr        ?
getScanLine				cptr		?
putScanLine				cptr		?
stretchScanLine2x		cptr		?
stretchScanLine			cptr		?

setWriteMode			cptr		?
setPenStyle				cptr		?
setLineStipple			cptr		?
setLineStippleCount		cptr		?
setPenBitmapPattern		cptr		?
setPenPixmapPattern		cptr		?
ditherPixel				cptr		?
putSrcTransparent		cptr		?
putDstTransparent		cptr		?

; Vectors that have corresponding emulated routines
putMonoImage        	cptr        ?
putMouseImage			cptr		?
getImage				cptr		?
putImage				cptr		?
divotSize				cptr		?
getDivot            	cptr        ?
putDivot            	cptr        ?
stretchBlt1x2			cptr		?
stretchBlt2x2			cptr		?
stretchBlt				cptr		?

cur						rVecs_s		<>
solid					rVecs_s		<>
ropSolid				rVecs_s		<>
patt                    rVecs_s		<>
colorPatt               rVecs_s		<>
fatSolid                rVecs_s		<>
fatRopSolid				rVecs_s		<>
fatPatt                 rVecs_s		<>
fatColorPatt            rVecs_s		<>
dither                  rVecs_s		<>

stippleLine             cptr		?
getArcCoords        	cptr        ?
drawStrBitmap			cptr		?
drawCharVec				cptr		?
complexPolygon      	cptr        ?
polygon       			cptr        ?
ditherPolygon			cptr		?
translateImage			cptr		?
bitBlt					cptr		?
srcTransBlt				cptr		?
dstTransBlt				cptr		?
scanRightForColor   	cptr        ?
scanLeftForColor    	cptr        ?
scanRightWhileColor 	cptr        ?
scanLeftWhileColor  	cptr        ?

; Hardware offscreen device bitBlt support
bitBltOff				cptr		?
srcTransBltOff			cptr		?
dstTransBltOff			cptr		?
bitBltLin				cptr		?
srcTransBltLin			cptr		?
dstTransBltLin			cptr		?

; 3D rasterisation
cLine					cptr		?
rgbLine					cptr		?
tri						cptr		?
ditherTri				cptr		?
cTri					cptr		?
rgbTri					cptr		?
quad					cptr		?
ditherQuad				cptr		?
cQuad					cptr		?
rgbQuad					cptr		?
cTrap					cptr		?
rgbTrap					cptr		?

; 3D Z-buffer rasterisation

zBegin					cptr		?
z						zVecs_s		<>
z16						zVecs_s		<>
z24						zVecs_s		<>
z32						zVecs_s		<>

ends	vecs_s

struc	devCtx_s
a                   	attributes_s <>
surface					dptr		?
zbuffer					dptr		?
zbits					uint		?
zwidth					uint		?
mi                  	mode_t_s	<>
pf                  	pixel_format_s <>
colorTab            	dptr		?
shadeTab				dptr		?
bankOffset				uint		?
size					rect_s		?
flags					ulong		?
v						dptr		?
zOffset					dptr		?
surfaceStart			dptr		?
originOffset			ulong		?
yOffset					uint		?
virtualX				uint		?
virtualY                uint		?
numBuffers				uint		?
frontBuffer				uint		?
backBuffer				uint		?
glDrawBuffer			uint		?
startX                  uint		?
startY                  uint		?
CRTCBase				ulong		?
wm						wm_vars_s	<>
ownMemory				bool		?
visual					dptr		?
rc						dptr		?
cntVis					MGLVisual_s <>
memdc					dptr		?
tr						trap_t_s	?
clipRectFX				rectFX_s	?
viewPortFX				rectFX_s	?
ellipseFixup			uint		?
intColor            	color_t		?
intBackColor        	color_t		?
intClipRect         	rect_s		<>
intClipRectFX       	rectFX_s	<>
doClip					uint		?
ac						arc_coords_s <>
deviceType          	uint		?
xInch               	uint		?
yInch               	uint		?
mglEnabled				bool		?
glViewport				uint 4 dup (?)
glCntColor				dq 4 dup (?)
glSwapbytes				uint		?
glLsbfirst              uint		?
glRowlength				uint		?
glSkiprows				uint		?
glSkippixels			uint		?
glAlignment				uint		?
glLighting				bool		?
glDepthTest				bool		?

r						vecs_s		<>
ends	devCtx_s
MGLDC	= (devCtx_s PTR _ES _BX)
GDC		EQU	__MGL_dc

MACRO   LOAD_GDC_INTO_ESBX
ife flatmodel
		mov     bx,seg __MGL_dc
		mov		es,bx
endif
		mov		_bx,offset __MGL_dc
ENDM

;----------------------------------------------------------------------------
; MGL_setupDither
;----------------------------------------------------------------------------
; Macro to setup the static unchanging register values for halftone
; dithering given a 24 bit RGB color value as input.
;
;	Entry:		CL  - 8 bit blue component
;				CH  - 8 bit green component
; 				DL  - 8 bit red component
;
;	Exit:		BL	- R / 51
; 				BH 	- R % 51
; 				CL 	- G / 51
; 				CH 	- G % 51
; 				DL 	- B / 51
; 				DL 	- B % 51
;----------------------------------------------------------------------------
MACRO   MGL_setupDither
		xor		eax,eax
		mov		al,dl					; EAX := R
		mov		bl,[__MGL_div51+eax]	; BL := R / 51
		mov		bh,[__MGL_mod51+eax]	; BH := R % 51
		mov		al,cl					; EAX := B
		mov		dl,[__MGL_div51+eax]	; DL := B / 51
		mov		dh,[__MGL_mod51+eax]	; DH := B % 51
		mov		al,ch					; EAX := G
		mov		cl,[__MGL_div51+eax]	; CL := G / 51
		mov		ch,[__MGL_mod51+eax]	; CH := G % 51
ENDM

;----------------------------------------------------------------------------
; MGL_ditherPixelStatic
;----------------------------------------------------------------------------
; Macro to dither a pixel with the same color as a previous pixel given
; that the registers have already been set up.
;
;	Entry:		EDI - x coordinate
; 				ESI - __MGL_dither8x8 = (Y & 7) << 3
;				BL	- R / 51
; 				BH 	- R % 51
; 				CL 	- G / 51
; 				CH 	- G % 51
; 				DL 	- B / 51
; 				DL 	- B % 51
;
;	Exit:		AL	- Halftone dithered pixel value
;				EDI	- Unchanged
;				ESI - Unchanged
;----------------------------------------------------------------------------
MACRO   MGL_ditherPixelStatic
		local	L1,L2,L3
		mov		eax,edi
		and		eax,7
		mov		al,[esi+eax]			; AL := dither threshold
		cmp		bh,al					; BH > dither threshold?
		jle		L1
		inc		bl						; BL := 2.6 bit R component
L1:		cmp		ch,al					; CH > dither threshold?
		jle		L2
		inc		cl						; CL := 2.6 bit G component
L2: 	cmp		dh,al					; DH > dither threshold?
		jle		L3
		inc		dl						; DL := 2.6 bit B component
L3: 	mov		al,cl
		mov		cl,[__MGL_mul6 + eax]
		mov		al,dl
		add		bl,cl
		mov		al,[__MGL_mul36 + eax]
		add		al,bl
		add		al,20					; Offset to start at index 20
ENDM

;----------------------------------------------------------------------------
; MGL_ditherPixel
;----------------------------------------------------------------------------
; Macro to compute the halfToned color map index for a 24 bit RGB pixel
; value.
;
;	Entry:		CL  - 8 bit blue component
;				CH  - 8 bit green component
; 				DL  - 8 bit red component
;				EDI - x coordinate
; 				ESI - __MGL_dither8x8 = (Y & 7) << 3
;
;	Exit:		AL 	- HalfToned pixel index
;				EDI	- Unchanged
;				ESI - Unchanged
;				EBX	- Trashed!!
;----------------------------------------------------------------------------
MACRO   MGL_ditherPixel
		MGL_setupDither
		MGL_ditherPixelStatic
ENDM

;----------------------------------------------------------------------------
; MGL_initialMinMax
;----------------------------------------------------------------------------
; Macro to find the initial minimum and maximum values from a vertex.
;
;	Entry:      EBX	- Points to vertex to process
;
;	Exit:		EAX	- Trashed!!
; 				ECX - New minimum left coordinate
; 				EDX - New maximum right
; 				ESI - New minimum top
; 				EDI - New maximum bottom
;----------------------------------------------------------------------------
MACRO	MGL_initialMinMax   point
		mov		eax,[point.x]
		mov		ecx,eax
		mov		edx,eax
		mov		eax,[point.y]
		mov		esi,eax
		mov     edi,eax
ENDM

;----------------------------------------------------------------------------
; MGL_findMinMax
;----------------------------------------------------------------------------
; Macro to find the minimum and maximum values from a vertex.
;
;	Entry:      EBX	- Points to vertex to process
; 				ECX - Current minimum left coordinate
; 				EDX - Current maximum right
; 				ESI - Current minimum top
; 				EDI - Current maximum bottom
;
;	Exit:		EAX	- Trashed!!
; 				ECX - New minimum left coordinate
; 				EDX - New maximum right
; 				ESI - New minimum top
; 				EDI - New maximum bottom
;----------------------------------------------------------------------------
MACRO	MGL_findMinMax	point
		local	L1,L2,L3,L4
		mov		eax,[point.x]
		cmp     eax,ecx			; Find minimum X
		jge		L1
		mov		ecx,eax
		jmp		L2
L1:   	cmp		eax,edx			; Find maximum X
		jle		L2
		mov		edx,eax
L2:		mov		eax,[point.y]
		cmp     eax,esi			; Find minimum Y
		jge		L3
		mov		esi,eax
		jmp		L4
L3:    	cmp		eax,edi			; Find maximum Y
		jle		L4
		mov		edi,eax
L4:
ENDM

;----------------------------------------------------------------------------
; MGL_offsetRect
;----------------------------------------------------------------------------
; Macro to offset the rectangle values
;
;	Entry:      EBX		- Points to vertex to process
; 				ECX 	- Current left coordinate
; 				EDX 	- Current right
; 				ESI 	- Current top
; 				EDI 	- Current bottom
;				xOffset	- X coordinate offset value
;				yOffset	- Y coordinate offset value
;
;	Exit:		EAX		- Trashed!!
;				EBX		- Trashed!!
; 				ECX 	- New left coordinate
; 				EDX 	- New right
; 				ESI 	- New top
; 				EDI 	- New bottom
;----------------------------------------------------------------------------
MACRO	MGL_offsetRect	xOffset,yOffset
		mov		eax,xOffset
		mov     ebx,yOffset
		add		ecx,eax
		add		edx,eax
		add		esi,ebx
		add		edi,ebx
ENDM

;----------------------------------------------------------------------------
; MGL_sectRect
;----------------------------------------------------------------------------
; Macro to find the intersection between two rectangles
;
;	Entry:
;				ECX 	- Rectangle 1 left coordinate
; 				EDX 	- Rectangle 1 right coordinate
; 				ESI 	- Rectangle 1 top coordinate
; 				EDI 	- Rectangle 1 bottom coordinate
;				rect	- Name of rectangle 2
;
;	Exit:		EAX		- Trashed!!
; 				ECX 	- Intersection left coordinate
; 				EDX 	- Intersection right coordinate
; 				ESI 	- Intersection top coordinate
; 				EDI 	- Intersection bottom coordinate
;----------------------------------------------------------------------------
MACRO   MGL_sectRect    rect
		local	L1,L2,L3,L4
		mov		eax,[rect.left]
		cmp     ecx,eax
		jge		L1
		mov		ecx,eax			; ECX := MAX(left,clip.left)
L1:		mov		eax,[rect.right]
		cmp     edx,eax
		jle		L2
		mov		edx,eax			; EDX := MIN(right,clip.right)
L2:		mov		eax,[rect.top]
		cmp     esi,eax
		jge		L3
		mov		esi,eax			; ESI := MAX(top,clip.top)
L3:		mov		eax,[rect.bottom]
		cmp     edi,eax
		jle		L4
		mov		edi,eax			; EDI := MIN(bottom,clip.bottom)
L4:
ENDM

;----------------------------------------------------------------------------
; MGL_checkEmpty
;----------------------------------------------------------------------------
; Macro to check if the intersection rectangle is empty, the same as or
; a valid intersection of the initial rectangle.
;
;	Entry:		ECX 	- Rectangle 1 left coordinate
; 				EDX 	- Rectangle 1 right coordinate
; 				ESI 	- Rectangle 1 top coordinate
; 				EDI 	- Rectangle 1 bottom coordinate
;				left,top,right,bottom - Values to check against
;
;	Exit:		0 for draw no clip, 1 for clip and draw, -1 for trival reject
;----------------------------------------------------------------------------
MACRO   MGL_checkEmpty    left,top,right,bottom
		local	Done

		mov		eax,-1				; Default to trivial reject case
		cmp     ecx,edx				; Is left >= right?
		jge		Done				; Yep, so trivially reject
		cmp     esi,edi				; Is top >= bottom?
		jge		Done				; Yep, so trivially reject

; Intersection is valid

		mov		eax,1				; Default to draw with clip
		cmp     ecx,left
		jne		Done				; Draw with clipping
		cmp		edx,right
		jne		Done				; Draw with clipping
		cmp		esi,top
		jne		Done				; Draw with clipping
		cmp		edi,bottom
		jne		Done				; Draw with clipping

		xor		eax,eax				; Trivially accept!!
Done:
ENDM

ifdef	__WIN386__
USE_SELVMEM		EQU	1
endif

;----------------------------------------------------------------------------
; lVid    - Macro to load video memory address into es:reg
;----------------------------------------------------------------------------
; This macro loads the video memory address in to ES:REG. For 16 bit code
; this simply loads the 32 bit far pointer into ES:REG. For 32 bit protected
; mode code this simply loads EREG with the offset of the video memory.
;
; For Watcom C++ Win386 mode this function loads EREG with the offset within
; video memory and loads the selector to the video memory into ES. Currently
; we are not able to map linear pointers to video memory in Win386 mode, so
; we need to load a selector to the video memory.
;----------------------------------------------------------------------------
MACRO   lVid reg
ifdef   USE_SELVMEM
		mov     es,[WORD (GDC.surface)+2]
		movzx   reg,[WORD GDC.surface]
else
		_les    reg,[GDC.surface]
endif
ENDM

;----------------------------------------------------------------------------
; lVidDC    - Macro to load video memory address into es:reg
;----------------------------------------------------------------------------
; This macro loads the video memory address in to ES:REG. For 16 bit code
; this simply loads the 32 bit far pointer into ES:REG. For 32 bit protected
; mode code this simply loads EREG with the offset of the video memory.
;
; For Watcom C++ Win386 mode this function loads EREG with the offset within
; video memory and loads the selector to the video memory into ES. Currently
; we are not able to map linear pointers to video memory in Win386 mode, so
; we need to load a selector to the video memory.
;----------------------------------------------------------------------------
MACRO   lVidDC reg
ifdef   USE_SELVMEM
		mov     es,[WORD (MGLDC.surface)+2]
		movzx   reg,[WORD MGLDC.surface]
else
		_les    reg,[MGLDC.surface]
endif
ENDM

; All banked access to video memory goes via the ES selector for Watcom
; Win386 mode. We also must save/restore the value of ES across functions
; that use it.

ifdef   USE_SELVMEM
_ES     EQU ES:
endif

MACRO   save_es
ifdef   USE_SELVMEM
        push    es
endif
ENDM

MACRO   restore_es
ifdef   USE_SELVMEM
        pop     es
endif
ENDM

MACRO   save_ds
ifdef   USE_SELVMEM
		push    ds
else
		use_ds
endif
ENDM

MACRO   restore_ds
ifdef   USE_SELVMEM
		pop     ds
else
		unuse_ds
endif
ENDM

; Macros for setting the value of the DS,ES,FS,GS registers to the same
; value. This does nothing in 32 bit protected mode, except for compilers
; that assume that DS != ES (Symantec C++ is one) and hence ES is always
; available to be loaded with any value you desire.

MACRO	ds_eq_es
ife flatmodel
		push	es
		pop		ds
endif
ifdef	USE_SELVMEM
		push	es
		pop		ds
endif
ENDM

MACRO	es_eq_ds
ife flatmodel
		push	ds
		pop		es
endif
ENDM

MACRO	ds_eq_es_swap
ife	flatmodel
		ds_eq_es
endif
ifdef	USE_SELVMEM
		push	_ax
		mov		ax,ds
		push	es
		pop		ds
		mov		es,ax
		pop		_ax
endif
ENDM

ife	flatmodel
USING_DS		EQU		1
endif

ifdef   USE_SELVMEM
USING_DS		EQU		1
endif
